<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Yoanp</title>
    <link>https://yoanp.github.io/</link>
    <description>Recent content on Yoanp</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 13 Aug 2019 14:51:17 +0900</lastBuildDate>
    
	<atom:link href="https://yoanp.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Ansible을 활용한 운영 자동화 환경 구축</title>
      <link>https://yoanp.github.io/blog/ansible%EC%9D%84-%ED%99%9C%EC%9A%A9%ED%95%9C-%EC%9A%B4%EC%98%81-%EC%9E%90%EB%8F%99%ED%99%94-%ED%99%98%EA%B2%BD-%EA%B5%AC%EC%B6%95/</link>
      <pubDate>Tue, 13 Aug 2019 14:51:17 +0900</pubDate>
      
      <guid>https://yoanp.github.io/blog/ansible%EC%9D%84-%ED%99%9C%EC%9A%A9%ED%95%9C-%EC%9A%B4%EC%98%81-%EC%9E%90%EB%8F%99%ED%99%94-%ED%99%98%EA%B2%BD-%EA%B5%AC%EC%B6%95/</guid>
      <description>요즘 Cloud Native☁️란 말을 많이 듣고 있습니다.
클라우드 컴퓨팅 모델의 장점을 모두 활용하여 서비스를 개발하고 운영하는 방식이죠.
클라우드 환경에서 서비스를 시작한 회사, 많은 준비와 시행착오 끝에 Cloud 환경으로 모든 서비스를 옮긴 회사를 제외하고 서비스 특성, 환경 혹은 리소스 등의 여러가지 이유로 On Premise 환경과 Cloud 환경 모두 서비스를 운영하고 제공하는 경우가 많습니다. (제가 요기 속해있습니다.)
당연한 말이지만 서비스가 많아지면 많아질수록 운영 난이도는 올라갑니다.
관리 포인트가 늘어나고 접근 방식이 달라지며 결정적으로 할일이 많아집니다.</description>
    </item>
    
    <item>
      <title>About</title>
      <link>https://yoanp.github.io/about/</link>
      <pubDate>Mon, 12 Aug 2019 22:11:39 +0900</pubDate>
      
      <guid>https://yoanp.github.io/about/</guid>
      <description> DevOps 문화를 사랑하는 시스템엔지니어입니다.
업무 효율을 중시하며 반복적인 업무에 대한 자동화, 운영에 필요한 개발을 좋아합니다.
Skills  Linux, aws Docker, Ansible Ansible, Rundeck Go, Python, Node.js  </description>
    </item>
    
    <item>
      <title>CAP 원리</title>
      <link>https://yoanp.github.io/blog/cap-%EC%9B%90%EB%A6%AC/</link>
      <pubDate>Mon, 05 Jun 2017 22:24:26 +0900</pubDate>
      
      <guid>https://yoanp.github.io/blog/cap-%EC%9B%90%EB%A6%AC/</guid>
      <description>클라우드 시스템을 관리하는 기술책을 읽으며 개인적으로 정리하는 내용입니다.
CAP Consistency, Availability, Partition resistance를 뜻한다.
CAP 원리 일관성과 가용성, 그리고 분리에 대한 저항을 모두 보장하는 분산 시스템을 구축하는 것은 불가능 하다는 것이 CAP 원리이다. 둘중 임의의 하나, 둘은 달성 할 수 잇지만 셋을 동시에 달성 할 수 없다. 따라서 시스템을 사용할 때에 무엇이 보장되고 무엇이 보장되지 않는지를 반드시 확인해야 한다.
일관성 모든 노드가 같은 시점에서 같은 자료를 본다는 뜻이다. 일관성을 보장하는 시스템은 다수의 복제본에 데이터 업데이트가 진행 되는 도중에 어떤 복제본에서 데이터를 읽는다고 해도 같은 시점에 동일하게 갱신 된 자료를 보게 된다는 것이다.</description>
    </item>
    
    <item>
      <title>PCS를 이용한 HA구성</title>
      <link>https://yoanp.github.io/blog/pcs%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-ha%EA%B5%AC%EC%84%B1/</link>
      <pubDate>Sat, 04 Mar 2017 13:45:07 +0900</pubDate>
      
      <guid>https://yoanp.github.io/blog/pcs%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-ha%EA%B5%AC%EC%84%B1/</guid>
      <description>pcs: pacemaker/corosync 설정,관리 시스템
 pacemaker: 고가용성 클러스터 리소스 관리자 (고장을 인지한 경우 대기장비로 서비스를 넘깁니다.- failover)
corosync: 그룹커뮤니케이션 시스템을 구현하기 위한 HA기능 API 제공 (node status)
 pcs를 이용하여 두대의 서버를 하나의 클러스터로 묶어 HA를 구현합니다.
마스터 서버 장애시 스탠바이 장비가 마스터로 승계됩니다.
두대 서버 모두 동일한 데이터를 유지하고 있어야 하기 때문에 이 문서에서는 단순 동기화 방식이 아닌 drbd를 구성 할 예정입니다.
 drbd: HA 클러스터를 위해 디자인 된 네트워크 블럭 디바이스</description>
    </item>
    
    <item>
      <title>direct-lvm mode for docker</title>
      <link>https://yoanp.github.io/blog/direct-lvm-mode-for-docker/</link>
      <pubDate>Thu, 23 Feb 2017 22:40:37 +0900</pubDate>
      
      <guid>https://yoanp.github.io/blog/direct-lvm-mode-for-docker/</guid>
      <description>Docker는 ubuntu를 기반으로 개발되었습니다.
그렇기 떄문에 도커의 기본적인 파일 스토리지 시스템은 AUFS입니다.
문제는 AUFS는 레드헷 개열에서 지원하지 않는 파일시스템이지요.
도커가 유명해지면서 REHL에서 사용하길 원하는 니즈가 급증하자 Redhat과 docker에서 협력하여 파일 스토리지 시스템 드라이버를 개발하였습니다. 해당 드라이버의 이름이 Devicemapper입니다. 도커의 두번째 공식 파일 스토리지 드라이버가 되었지요. 그래서 레드햇 계열 리눅스에 도커를 설치하면 Devicemapper가 드라이버로 loop-lvm 모드로 올라옵니다. 문제는 상용으로 사용시 loop-lvm으로 사용하면 안된다는 점입니다.
 1.13.1 버전부터 Overlay2 또는 Overlay가 Devicemapper대신 기본 스토리지 드라이버로 설정되어 올라옵니다.</description>
    </item>
    
    <item>
      <title>Docker 1.13 Release</title>
      <link>https://yoanp.github.io/blog/docker-1.13-release/</link>
      <pubDate>Fri, 20 Jan 2017 22:19:09 +0900</pubDate>
      
      <guid>https://yoanp.github.io/blog/docker-1.13-release/</guid>
      <description>1월 19일날 발표 된 docker 1.13의 특징을 소개하는 글 입니다. 도커 공식 블로그을 참고하였습니다.
root # docker --version Docker version 1.13.0, build 49bf474  특히 도커 swarm mode가 1.12에 소개되었는데 해당 기능에 대한 기능개선과 변경사항이 생겼습니다.
compose로 swarm mode 서비스를 배포 할 수 있습니다 docker stack deploy란 명령어를 통해 compose 파일을 지원합니다. 구축 및 서비스 관리가 편해지겠습니다.
예전버전과의 호환성 유지 도커 데몬보다 클라이언트가 최신버전일 경우 에러가 발생했습니다.
Error response from daemon: client is newer than server  이젠 그렇지 않다고 합니다.</description>
    </item>
    
    <item>
      <title>Docker swarm</title>
      <link>https://yoanp.github.io/blog/docker-swarm/</link>
      <pubDate>Sun, 04 Dec 2016 16:20:06 +0900</pubDate>
      
      <guid>https://yoanp.github.io/blog/docker-swarm/</guid>
      <description>docker swarm 도커 1.9 버전에서 베타 딱지를 붙인 채 세상에 나왔던 Swarm은 2016년 7월에 도커 1.12버전 릴리즈때 베타 딱지를 떼고 도커 엔진에 포함 된 채로 새롭게 나왔습니다. (물론 기존의 Swarm 또한 지원 합니다.)
도커 엔진 자체에 포함 된 만큼 여러가지 변화가 생겼습니다.
 도커 엔진 자체에 포함 도커 엔진에서 swarm mode를 on/off 가능 오버레이 네트워크와 swarm mode의 연계 (외부 키값 저장소가 필요하지 않아짐) native remote api, cli supported  도커사에서 공식적으로 말하고 있는 swarm의 특징은 아래와 같습니다.</description>
    </item>
    
    <item>
      <title>SSL convert</title>
      <link>https://yoanp.github.io/blog/ssl-convert/</link>
      <pubDate>Sun, 04 Dec 2016 16:17:20 +0900</pubDate>
      
      <guid>https://yoanp.github.io/blog/ssl-convert/</guid>
      <description>CRT 파일을 PFX로 변환 Key 파일, Crt 파일, Chain 파일을 PFX 파일로 합체시켜보겠습니다.
openssl pkcs12 -export -out server.pfx -inkey server.key -in server.crt -certfile server_CHAIN.crt  PFX에서 키 뽑아내기 PFX에서 KEY 뽑아내기 openssl pkcs12 -in server.pfx -nocerts -passin pass:&#39;PASSWORD&#39; -nodes -out server.key sed -ni -e &#39;/^-----BEGIN/,/-----END/p&#39; server.key  PFX에서 인증서(crt) 뽑아내기 openssl pkcs12 -in server.pfx -clcerts -nokeys -passin pass:&#39;PASSWORD&#39; -out server.crt sed -ni -e &#39;/^-----BEGIN/,/-----END/p&#39; server.crt  PFX에서 체인인증서 뽑아내기 openssl pkcs12 -in server.</description>
    </item>
    
    <item>
      <title>Linux Performance Analysis</title>
      <link>https://yoanp.github.io/blog/linux-performance-analysis/</link>
      <pubDate>Sun, 04 Dec 2016 16:14:34 +0900</pubDate>
      
      <guid>https://yoanp.github.io/blog/linux-performance-analysis/</guid>
      <description>넷플릭스 테크 블로그에 올라온 포스트를 번역하였습니다. 시스템 엔지니어로써 기본적으로 알아야하는 명령어들입니다. 리마인드 겸 제 입맛에 맞게 해석-작성되었으니.. 참고해주시면 감사하겠습니다.
당신은 서버의 퍼포먼스 이슈가 발생하여 서버에 로그인 하였을 때 1분 동안 확인 하는 것이 무엇입니까?
우리(넷플릭스)는 거대한 EC2 리눅스 클라우드를 가지고 있으며, 다수의 퍼포먼스 분석 툴을 이용한 모니터링 및 퍼포먼스에 대한 연구를 진행하고 있습니다.
그 툴들에는 Atlas 와 Vector 가 포함되어 있지요. 이러한 도구들은 대부분의 이슈를 해결하는데 도움이 되지만, 때때로 인스턴스에 접근하여 기존의 보편적인 리눅스 퍼포먼스 툴을 사용해야 하는 일들이 생깁니다.</description>
    </item>
    
    <item>
      <title>runit</title>
      <link>https://yoanp.github.io/blog/runit/</link>
      <pubDate>Sun, 04 Dec 2016 00:07:31 +0900</pubDate>
      
      <guid>https://yoanp.github.io/blog/runit/</guid>
      <description>runit이란, 유닉스 크로스 플랫폼에서 작동하는 서비스 관리 프로그램 입니다.
비슷한 종류로는 init, launchdm, systemd 등이 있습니다.
구동되는 플랫폼은 아래와 같지요.
 GNU/Linux *BSD MacOSX Solaris  서비스들이 runsv 의 child process로 실행이 되며, 관리를 받게 됩니다.
(runsv : 서비스 데몬의 신호, 서비스 컨트롤 및 관리를 담당.)
또한 sv를 이용하여 모니터링 되고 있는 서비스들을 관리 할 수 있습니다.
저는 runit을 1번 프로세스로 사용하지 않고(systemd를 사용하지요) 특정 프로세스의 감시 툴로써 nginx를 모니터링 하고 auto restart 처리를 할 예정입니다.</description>
    </item>
    
  </channel>
</rss>